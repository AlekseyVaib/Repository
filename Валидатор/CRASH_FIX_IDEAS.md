# Идеи по устранению падений и потери прогресса

При больших базах программа иногда вылетает и теряется весь прогресс. Ниже — возможные причины и способы решения (без изменений в коде на данном этапе).

## 1. Память (самое вероятное)

**Проблема:** В памяти держится весь список `results` (результаты по каждой почте). При 100–500 тыс. адресов это десятки–сотни МБ (pandas + объекты Python).

**Что можно сделать:**
- **Стриминг в файл:** не накапливать все результаты в списке, а писать строки в CSV/Excel по мере проверки (по одной или батчами). Итоговый Excel собирать в конце из чанков или оставить CSV.
- **Уменьшить чанк прогресса:** уже есть чекпоинты каждые 1000 строк. Можно снизить до 100–300 и после каждого чанка явно вызывать `gc.collect()`.
- **Ограничить размер батча в pandas:** при сохранении чекпоинта не держать в памяти старые чекпоинты; по возможности переходить на запись в один открытый файл (например, через `openpyxl` в append-режиме или CSV).
- **Запуск с большим heap:** `python -X pycache_prefix=...` не поможет, а вот увеличение лимита памяти для процесса (если есть) или запуск на машине с большим RAM может временно снять проблему.

## 2. Сохранение прогресса и восстановление

**Проблема:** При падении весь прогресс теряется.

**Что можно сделать:**
- **Чекпоинты:** уже есть сохранение каждые 1000 писем. Важно: при старте проверять наличие чекпоинт-файлов для этого же входного файла и предлагать «продолжить с N» или автоматически продолжать, догружая уже проверенные email из чекпоинта и проверяя только оставшиеся.
- **Файл «обработанных»:** вести простой файл (или SQLite) с уже обработанными email (или хэшами). При перезапуске пропускать их и проверять только новые.
- **Идемпотентность по файлу:** один и тот же входной файл при повторном запуске — подхватывать последний чекпоинт и продолжать, а не начинать с нуля.

## 3. Стабильность процесса

- **Логирование:** при падении писать в лог последний обработанный email и номер строки; при следующем запуске можно продолжать с этой позиции.
- **Обработка исключений:** обернуть цикл по email в `try/except` на верхнем уровне: при необработанном исключении сохранить чекпоинт с тем, что успели обработать, и записать в лог ошибку и место остановки.
- **Таймауты и лимиты:** убедиться, что сетевые запросы (DNS, SMTP) не висят бесконечно и не создают бесконечный рост очереди/памяти (например, ограничить число одновременных соединений, если будет асинхронность).

## 4. Дополнительно

- **Отдельный процесс для тяжёлой валидации:** вынести проверку в отдельный worker-процесс (или отдельный скрипт). При падении worker’а основной веб-процесс не падает, а пользователь может перезапустить задачу и, при реализации п.2, продолжить с чекпоинта.
- **Мониторинг памяти:** в лог периодически писать `memory_usage` (например, через `psutil` или `resource`). Это поможет подтвердить, что падения совпадают с ростом памяти.

Имеет смысл начать с **п.1 (стриминг/меньше данных в памяти)** и **п.2 (продолжение с чекпоинта)** — это даст и устойчивость к памяти, и сохранение прогресса при любых сбоях.
